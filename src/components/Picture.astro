---
import type { ImageMetadata, ImageOutputFormat } from "astro";
import { getImage } from "astro:assets";

export interface Props {
	src: ImageMetadata | Promise<ImageMetadata>;
	classes?: string[];
	hideByDefault?: boolean;
	imageWidths: number[];
	imageFormats: ImageOutputFormat[];
}

const { src, classes, hideByDefault, imageWidths, imageFormats } = Astro.props;

const pictureFormats = [];
for (const format of imageFormats) {
	const pictureWidths = [];
	for (const width of imageWidths) {
		pictureWidths.push(
			await getImage({
				// @ts-expect-error Astro's type definitions here are contradictory and unusuable AFAICT
				src: src,
				format: format,
				width: width,
			}),
		);
	}
	pictureFormats.push(pictureWidths);
}

const mostCompatiblePictureSource =
	pictureFormats[imageFormats.length - 1][imageWidths.length - 1];
---

<picture>
	{
		pictureFormats.map((format) => (
			<source
				srcset={format
					.map(
						(resizedSource) =>
							`${resizedSource.src} ${resizedSource.options.width}w`,
					)
					.join(",")}
				type={`image/${format[0].options.format}`}
			/>
		))
	}
	<img
		src={mostCompatiblePictureSource.src}
		{...mostCompatiblePictureSource.attributes}
		alt=""
		class:list={[...(hideByDefault ? ["opacity-0"] : []), ...(classes ?? [])]}
	/></picture
>
